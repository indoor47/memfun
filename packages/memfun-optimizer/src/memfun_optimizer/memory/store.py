"""Event-sourced memory store with persistent backend.

This module provides the MemoryStore class, which manages persistent storage
of memory entries via the StateStoreAdapter protocol. It supports CRUD operations,
search, and daily summary generation.
"""
from __future__ import annotations

import json
import re
import time
import uuid
from collections import defaultdict
from datetime import datetime
from typing import TYPE_CHECKING

from memfun_core.logging import get_logger

if TYPE_CHECKING:
    from memfun_runtime.protocols.state_store import StateStoreAdapter

    from memfun_optimizer.memory.types import (
        DailySummary,
        MemoryEntry,
        MemoryQuery,
        MemorySearchResult,
    )

logger = get_logger("optimizer.memory")

# Key prefix for memory storage in the state store
_MEMORY_PREFIX = "memfun:memory:"

# Safety limits to prevent unbounded growth
_MAX_ENTRIES_IN_MEMORY = 50_000
_MAX_ENTRIES_FOR_SEARCH = 10_000
_MAX_LIST_LIMIT = 10_000
_MAX_CONTENT_LENGTH = 100_000
_MAX_TOPIC_LENGTH = 256

# Entry ID must be hex (as generated by uuid4().hex)
_SAFE_ID_RE = re.compile(r"^[a-f0-9]{1,64}$")


def _validate_entry_id(entry_id: str) -> None:
    """Validate an entry ID to prevent key injection.

    Raises:
        ValueError: If the entry ID is invalid.
    """
    if not entry_id or not _SAFE_ID_RE.match(entry_id):
        msg = f"Invalid entry ID: {entry_id!r}"
        raise ValueError(msg)


class MemoryStore:
    """Event-sourced persistent memory store.

    Stores memory entries via the StateStoreAdapter protocol, with automatic
    fallback to in-memory storage if no backend is available. Supports full
    CRUD operations, keyword search, and daily summaries.

    Usage::

        store = MemoryStore(state_store)
        entry_id = await store.add(
            topic="bug_patterns",
            content="Null pointer dereferences often occur in async handlers",
            source="trace_analysis",
            confidence=0.9,
            tags=("bugs", "async"),
        )

        # Later: search for related knowledge
        query = MemoryQuery(query="async bugs", min_confidence=0.7)
        results = await store.search(query)

    Attributes:
        has_backend: Whether a persistent backend is available
    """

    def __init__(
        self,
        state_store: StateStoreAdapter | None = None,
    ) -> None:
        """Initialize the memory store.

        Args:
            state_store: Backend storage adapter. If None, uses in-memory fallback.
        """
        self._state_store = state_store
        self._in_memory: dict[str, MemoryEntry] = {}

    @property
    def has_backend(self) -> bool:
        """Whether a persistent backend is available."""
        return self._state_store is not None

    async def add(
        self,
        topic: str,
        content: str,
        *,
        source: str = "agent",
        confidence: float = 0.8,
        tags: tuple[str, ...] = (),
        metadata: dict | None = None,
    ) -> str:
        """Create and persist a new memory entry.

        Args:
            topic: High-level category
            content: The actual knowledge/fact
            source: Origin of this knowledge
            confidence: Confidence score (0.0-1.0)
            tags: Additional categorization tags
            metadata: Optional structured data

        Returns:
            The entry's unique ID
        """
        from memfun_optimizer.memory.types import MemoryEntry

        # Validate inputs to prevent unbounded growth
        if len(content) > _MAX_CONTENT_LENGTH:
            msg = f"Content exceeds maximum length ({len(content)} > {_MAX_CONTENT_LENGTH})"
            raise ValueError(msg)
        if len(topic) > _MAX_TOPIC_LENGTH:
            msg = f"Topic exceeds maximum length ({len(topic)} > {_MAX_TOPIC_LENGTH})"
            raise ValueError(msg)

        entry = MemoryEntry(
            id=uuid.uuid4().hex,
            topic=topic,
            content=content,
            source=source,
            confidence=confidence,
            tags=tags,
            created_at=time.time(),
            updated_at=time.time(),
            metadata=metadata or {},
        )

        key = f"{_MEMORY_PREFIX}{entry.id}"
        serialized = json.dumps(entry.to_dict())

        if self._state_store is not None:
            await self._state_store.set(key, serialized.encode("utf-8"))
            logger.debug(
                "Added memory entry %s (topic=%s, source=%s)",
                entry.id,
                topic,
                source,
            )
        else:
            # Guard against unbounded in-memory growth
            if len(self._in_memory) >= _MAX_ENTRIES_IN_MEMORY:
                logger.warning(
                    "In-memory store at capacity (%d entries); rejecting new entry",
                    _MAX_ENTRIES_IN_MEMORY,
                )
                msg = f"In-memory store at capacity ({_MAX_ENTRIES_IN_MEMORY} entries)"
                raise ValueError(msg)
            self._in_memory[entry.id] = entry
            logger.debug(
                "Added memory entry %s in-memory (topic=%s, source=%s)",
                entry.id,
                topic,
                source,
            )

        return entry.id

    async def get(self, entry_id: str) -> MemoryEntry | None:
        """Retrieve a memory entry by ID.

        Args:
            entry_id: The entry's unique ID

        Returns:
            The entry if found, None otherwise

        Raises:
            ValueError: If entry_id contains invalid characters.
        """
        from memfun_optimizer.memory.types import MemoryEntry

        _validate_entry_id(entry_id)

        if self._state_store is not None:
            key = f"{_MEMORY_PREFIX}{entry_id}"
            raw = await self._state_store.get(key)
            if raw is None:
                return None
            data = json.loads(raw)
            return MemoryEntry.from_dict(data)

        return self._in_memory.get(entry_id)

    async def update(
        self,
        entry_id: str,
        *,
        content: str | None = None,
        confidence: float | None = None,
        tags: tuple[str, ...] | None = None,
    ) -> MemoryEntry | None:
        """Partially update an existing memory entry.

        Only the specified fields are updated. The updated_at timestamp
        is automatically refreshed.

        Args:
            entry_id: The entry's unique ID
            content: New content (if provided)
            confidence: New confidence score (if provided)
            tags: New tags (if provided)

        Returns:
            The updated entry if found, None otherwise

        Raises:
            ValueError: If entry_id is invalid or content exceeds max length.
        """
        from memfun_optimizer.memory.types import MemoryEntry

        _validate_entry_id(entry_id)
        if content is not None and len(content) > _MAX_CONTENT_LENGTH:
            msg = f"Content exceeds maximum length ({len(content)} > {_MAX_CONTENT_LENGTH})"
            raise ValueError(msg)

        existing = await self.get(entry_id)
        if existing is None:
            return None

        # Build updated entry (frozen dataclass, so we must create a new one)
        updated = MemoryEntry(
            id=existing.id,
            topic=existing.topic,
            content=content if content is not None else existing.content,
            source=existing.source,
            confidence=confidence if confidence is not None else existing.confidence,
            tags=tags if tags is not None else existing.tags,
            created_at=existing.created_at,
            updated_at=time.time(),
            metadata=existing.metadata,
        )

        key = f"{_MEMORY_PREFIX}{entry_id}"
        serialized = json.dumps(updated.to_dict())

        if self._state_store is not None:
            await self._state_store.set(key, serialized.encode("utf-8"))
            logger.debug("Updated memory entry %s", entry_id)
        else:
            self._in_memory[entry_id] = updated
            logger.debug("Updated memory entry %s in-memory", entry_id)

        return updated

    async def delete(self, entry_id: str) -> bool:
        """Delete a memory entry by ID.

        Args:
            entry_id: The entry's unique ID

        Returns:
            True if the entry existed and was deleted, False otherwise

        Raises:
            ValueError: If entry_id contains invalid characters.
        """
        _validate_entry_id(entry_id)

        if self._state_store is not None:
            key = f"{_MEMORY_PREFIX}{entry_id}"
            exists = await self._state_store.exists(key)
            if exists:
                await self._state_store.delete(key)
                logger.debug("Deleted memory entry %s", entry_id)
            return exists

        deleted = self._in_memory.pop(entry_id, None)
        if deleted:
            logger.debug("Deleted memory entry %s from in-memory store", entry_id)
        return deleted is not None

    async def list_entries(
        self,
        topic: str | None = None,
        limit: int = 100,
    ) -> list[MemoryEntry]:
        """List memory entries, optionally filtered by topic.

        Args:
            topic: Filter by topic (if provided)
            limit: Maximum number of entries to return (capped at 10,000)

        Returns:
            List of memory entries
        """
        from memfun_optimizer.memory.types import MemoryEntry

        # Cap limit to prevent unbounded memory allocation
        limit = min(limit, _MAX_LIST_LIMIT)

        entries: list[MemoryEntry] = []

        if self._state_store is not None:
            async for key in self._state_store.list_keys(_MEMORY_PREFIX):
                if len(entries) >= limit:
                    break
                raw = await self._state_store.get(key)
                if raw is not None:
                    data = json.loads(raw)
                    entry = MemoryEntry.from_dict(data)
                    if topic is None or entry.topic == topic:
                        entries.append(entry)
        else:
            for entry in self._in_memory.values():
                if topic is None or entry.topic == topic:
                    entries.append(entry)
                if len(entries) >= limit:
                    break

        return entries

    async def search(self, query: MemoryQuery) -> list[MemorySearchResult]:
        """Search memory entries using the given query.

        Uses the MemorySearch engine to rank entries by relevance.

        Args:
            query: Search parameters

        Returns:
            Ranked list of search results
        """
        from memfun_optimizer.memory.search import MemorySearch

        # Load all entries (up to a reasonable limit for indexing)
        all_entries = await self.list_entries(limit=10000)

        # Index and search
        search_engine = MemorySearch()
        search_engine.index(all_entries)
        results = search_engine.search(query, all_entries)

        logger.debug(
            "Search query=%r returned %d results",
            query.query,
            len(results),
        )

        return results

    async def generate_daily_summary(
        self,
        date: str | None = None,
    ) -> DailySummary:
        """Generate a summary of memory activity for a given date.

        Args:
            date: ISO date string (YYYY-MM-DD). If None, uses today.

        Returns:
            Summary of entries added/updated and top topics
        """
        from memfun_optimizer.memory.types import DailySummary

        if date is None:
            date = datetime.now().strftime("%Y-%m-%d")

        # Parse the target date
        target_date = datetime.strptime(date, "%Y-%m-%d")
        start_of_day = target_date.timestamp()
        end_of_day = start_of_day + 86400  # +24 hours

        # Load all entries
        all_entries = await self.list_entries(limit=10000)

        # Filter entries created or updated on this date
        entries_added = 0
        entries_updated = 0
        topic_counts: dict[str, int] = defaultdict(int)

        for entry in all_entries:
            if start_of_day <= entry.created_at < end_of_day:
                entries_added += 1
                topic_counts[entry.topic] += 1
            elif start_of_day <= entry.updated_at < end_of_day:
                entries_updated += 1
                topic_counts[entry.topic] += 1

        # Top topics
        top_topics = sorted(
            topic_counts.keys(),
            key=lambda t: topic_counts[t],
            reverse=True,
        )[:5]

        # Generate summary text
        if entries_added == 0 and entries_updated == 0:
            summary_text = f"No memory activity on {date}."
        else:
            summary_text = (
                f"On {date}: {entries_added} new entries, "
                f"{entries_updated} updates. "
                f"Top topics: {', '.join(top_topics) if top_topics else 'none'}."
            )

        return DailySummary(
            date=date,
            entries_added=entries_added,
            entries_updated=entries_updated,
            top_topics=top_topics,
            summary_text=summary_text,
        )
